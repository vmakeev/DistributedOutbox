// <auto-generated/>
using DistributedOutbox.Postgres;
using Npgsql;
using NpgsqlTypes;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace DistributedOutbox.Postgres.Queries
{
    // ReSharper disable once PartialTypeWithSinglePart
    public partial class SelectElderEventsBySequenceNameQuery
    {
        private string _cachedSql;
        private readonly object _cachedSqlLocker = new object();

        /// <summary>
        /// Заготовка для определенной пользователем пост-обработки текста запроса
        /// </summary>
        /// <param name="queryText">Текст кэшированного sql-запроса</param>
        partial void ProcessCachedSql(ref string queryText);

        /// <summary>
        /// Возвращает текст запроса
        /// </summary>
        /// <returns>Текст запроса</returns>
        protected virtual string GetQueryText()
        {
            if (_cachedSql == null)
            {
                lock (_cachedSqlLocker)
                {
                    using (Stream stream = typeof(SelectElderEventsBySequenceNameQuery).Assembly.GetManifestResourceStream("DistributedOutbox.Postgres.Queries.SelectElderEventsBySequenceNameQuery.sql"))
                    {
                        string sql = new StreamReader(stream ?? throw new InvalidOperationException("Can not get manifest resource stream.")).ReadToEnd();

                        const string sectionRegexPattern = @"--\s*begin\s+[a-zA-Z0-9_]*\s*\r?\n.*?\s*\r?\n\s*--\s*end\s*\r?\n";
                        const RegexOptions regexOptions = RegexOptions.Singleline | RegexOptions.IgnoreCase | RegexOptions.Compiled;
                        sql = Regex.Replace(sql, sectionRegexPattern, string.Empty, regexOptions);

                        _cachedSql = sql;

                        ProcessCachedSql(ref _cachedSql);
                    }
                }
            }

            return _cachedSql;
        }

        /// <summary>
        /// Добавляет параметр к команде
        /// </summary>
        /// <param name="command">Команда SQL</param>
        /// <param name="parameterType">Тип параметра</param>
        /// <param name="parameterName">Имя параметра</param>
        /// <param name="value">Значение параметра</param>
        /// <param name="length">Длина параметра</param>
        protected virtual void AddParameter(IDbCommand command, NpgsqlDbType parameterType, string parameterName, object value, int? length = null)
        {
            var parameter = new NpgsqlParameter
            {
                ParameterName = parameterName,
                NpgsqlDbType = parameterType,
                Value = value ?? DBNull.Value
            };

            if (length.HasValue && length.Value > 0)
            {
                parameter.Size = length.Value;
            }
    
            command.Parameters.Add(parameter);
        }

        /// <summary>
        /// Возвращает новый элемент, заполненный данными из <paramref name="record"/>
        /// </summary>
        /// <param name="record">Строка БД</param>
        /// <returns>Новый элемент, заполненный данными из <paramref name="record"/></returns>
        protected virtual PostgresOutboxEventRaw GetItemFromRecord(IDataRecord record)
        {
            var result = new PostgresOutboxEventRaw();

            if (record[0] != null && record[0] != DBNull.Value)
            {
                result.Id = (long)record[0];
            }
            if (record[1] != null && record[1] != DBNull.Value)
            {
                result.SequenceName = (string)record[1];
            }
            if (record[2] != null && record[2] != DBNull.Value)
            {
                result.Type = (string)record[2];
            }
            if (record[3] != null && record[3] != DBNull.Value)
            {
                result.Key = (string)record[3];
            }
            if (record[4] != null && record[4] != DBNull.Value)
            {
                result.Date = (DateTime)record[4];
            }
            if (record[5] != null && record[5] != DBNull.Value)
            {
                result.Metadata = (string)record[5];
            }
            if (record[6] != null && record[6] != DBNull.Value)
            {
                result.Payload = (string)record[6];
            }
            if (record[7] != null && record[7] != DBNull.Value)
            {
                result.Status = (string)record[7];
            }
            if (record[8] != null && record[8] != DBNull.Value)
            {
                result.Targets = (string)record[8];
            }

            result.AfterLoad();
            return result;
        }

        /// <summary>
        /// Выполняет ленивую загрузку списка элементов типа <see cref="PostgresOutboxEventRaw"/>
        /// </summary>
        /// <param name="connection">Подключение к БД</param>
        /// <param name="sequenceName">sequenceName</param>
        /// <param name="limit">limit</param>
        /// <param name="cancellationToken">Токен отмены</param>
        /// <returns>Список элементов типа <see cref="PostgresOutboxEventRaw"/></returns>
        public virtual async IAsyncEnumerable<PostgresOutboxEventRaw> GetAsync(DbConnection connection, string sequenceName, long? limit, [EnumeratorCancellation] CancellationToken cancellationToken)
        {
            using DbCommand cmd = connection.CreateCommand();
            cmd.CommandText = GetQueryText();
            AddParameter(cmd, NpgsqlDbType.Text, "@sequenceName", sequenceName);
            AddParameter(cmd, NpgsqlDbType.Bigint, "@limit", limit);

            PrepareCommand(cmd);

            using DbDataReader reader = await cmd.ExecuteReaderAsync(cancellationToken);

            while (await reader.ReadAsync(cancellationToken))
            {
                yield return GetItemFromRecord(reader);
            }
        }

        /// <summary>
        /// Заготовка для определенной пользователем обработки команды перед исполнением
        /// </summary>
        /// <param name="command">Команда</param>
        partial void PrepareCommand(IDbCommand command);
    }
}